<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Archivansicht</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
      background-color: white;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.5rem;
      text-align: center;
    }
    th {
      background-color: #f0f0f0;
    }
  </style>
</head>
<body>
  <a href="admin.html" class="button">Admin</a>
  <a href="index.html" class="button">Kinderseite</a>
  <h1>Archivierte Gef√ºhle</h1>
  <button onclick="resetArchivDaten()" id="resetButton"  class="tooltip">
    üóëÔ∏è
    <span class="tooltiptext">Alle Eintr√§ge l√∂schen</span>
  </button>
  <table id="archivTabelle">
    <thead>
      <tr>
        <th>Code</th>
        <th>Gef√ºhl</th>
        <th>Zeit</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    function ladeArchivDaten() {
      fetch('/archivdaten')
        .then(res => res.json())
        .then(daten => {
          const tbody = document.querySelector('#archivTabelle tbody');
          tbody.innerHTML = '';

          // Nur die letzten Eintr√§ge je Code
          const letzterEintragProCode = new Map();
          
          console.log(daten, letzterEintragProCode)

          daten.forEach((eintrag) => {
            if (
              !letzterEintragProCode.has(eintrag.code) ||
              new Date(eintrag.timestamp) > new Date(letzterEintragProCode.get(eintrag.code).timestamp)
            ) {
              letzterEintragProCode.set(eintrag.code, eintrag);
            }
          });

          
          
          daten.forEach(eintrag => {
            const tr = document.createElement('tr');

            // Pr√ºfen ob es der neueste Eintrag f√ºr diesen Code ist
            const istLetzter = letzterEintragProCode.get(eintrag.code) === eintrag;
            if (istLetzter) tr.classList.add('highlight');

            const time = new Date(eintrag.timestamp + 'Z'); // 'Z' kennzeichnet UTC-Zeit

            tr.innerHTML = `
              <td>${eintrag.code}</td>
              <td>${eintrag.gefuehl}</td>
              <td>${time.toLocaleTimeString('de-DE', {
                timeZone: 'Europe/Berlin',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
              })}</td>
            `;
            tbody.appendChild(tr);
          });
        });
    }
    
    ladeArchivDaten();

    function resetArchivDaten() {
      if (confirm('Willst du wirklich alle Eintr√§ge l√∂schen?')) {
        fetch('/resetarchiv', {
          method: 'DELETE',
        })
          .then((res) => res.json())
          .then((data) => {
            if (data.success) 
              ladeArchivDaten();
            else {
              alert('Fehler beim L√∂schen.');
            }
          });
      }
    }
  </script>

   <!-- Diagramm pro Kind -->
  <h1> Diagramme</h1>
  <div id="diagramme" style="display: flex; flex-wrap: wrap; gap: 20px;"></div>

  <script src="chart.umd.min.js"></script>
  <script>

    function countGefuehle(array) {
      const counts = {};
      array.forEach(g => {
        counts[g] = (counts[g] || 0) + 1;
      });
      return counts;
    }

    const container = document.getElementById('diagramme');

    fetch('/archivdaten')
      .then(res => res.json())
      .then(async daten => {

        const groupedByCode = {};

        daten.forEach(data => {
          if (!groupedByCode[data.code]) {
            groupedByCode[data.code] = [];
          }
          groupedByCode[data.code].push(data.gefuehl);
        });

        const gefuehle_all = await fetch('/gefuehle.json').then(res => res.json())

        Object.entries(groupedByCode).forEach(([code, gefuehle], index) => {
          const counts = countGefuehle(gefuehle);

          const labels = Object.keys(counts);   // Gef√ºhle
          const data = Object.values(counts);   // Anzahl

          // Sucht f√ºr jedes Gef√ºhl aus der Datenbank die Farbe aus der gefuehle.json Zeile
          const colors = labels.map(gefuehl => {
            const found = gefuehle_all.find(value => value.id == gefuehl) // value ist immer eine Zeile aus gefuehle.json
            return found.color
          });


          // Create wrapper div
          const chartWrapper = document.createElement('div');
          chartWrapper.style.width = '300px';
          chartWrapper.style.height = '300px';

          // Create canvas
          const canvas = document.createElement('canvas');
          canvas.id = `chart_${index}`;
          canvas.width = 300;
          canvas.height = 300;

          chartWrapper.appendChild(canvas);
          container.appendChild(chartWrapper);


          const ctx = canvas.getContext('2d');

          // Create Chart
          new Chart(ctx, {
            type: 'doughnut', // or 'bar', 'pie'
            data: {
              labels: labels,
              datasets: [{
                label: `Gef√ºhle von ${code}`,
                data: data,
                backgroundColor: colors
              }]
            },
            options: {
              plugins: {
                title: {
                  display: true,
                  text: `Gef√ºhle von ${code}`, // angezeigter Titel des Diagramms
                  font: {
                    size: 18
                  }
                },
                legend: {
                  position: 'top' // Position des Titels
                }
              }
            }
          });
        });

        
      });

  </script>
</body>
</html>

<script src="/socket.io/socket.io.js"></script>
<script src="script.js"></script>
